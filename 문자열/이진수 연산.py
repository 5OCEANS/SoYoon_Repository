a = int(input(), 2)
b = int(input(), 2)

n = 100000
mask = 2 ** n - 1   # n자리의 1이 꽉찬 집합이 된다. (십진수로 생각하지말고 이진수로 생각해야 한다. ex. 3 = 11)

print(bin(a&b)[2:].zfill(n))  # 이진수는 0b를 붙여 표현해주기 때문에 2번째 자리부터 출력해야 한다.
print(bin(a|b)[2:].zfill(n))  # n 자리수에 맞게 앞에 0을 채워준다.
print(bin(a^b)[2:].zfill(n))  # 파이썬에서는 기본적으로 이진수 연산을 할 수 있다.

# not 연산자는 '~'를 그대로 사용하면 안 된다.

# 파이썬 not 연산자: 비트 반전 -> 1의 보수 -> 2의 보수 -> 음수 부호 붙여 리턴한다. :: 정수형으로 다루기 때문에 이런 과정을 거치는 것으로 예상.
# but 우리가 원하는 NOT 연산은 1의 보수까지이기 때문에 직접 해주어야 한다.


# 파이썬에서 1의 보수를 얻는 방법

# ~ A & mask -> 원래는 자기자신만 나오지만 파이썬은 형태가 특별하기 때문에 마스크로 and 연산만 다시 해주면 1의 보수 형태로만 나온다.
# A ^ mask -> ^: exclusive OR 연산, 2개의 명제 가운데 1개만 참일 경우를 판단
# mask - A

print(bin(mask - a)[2:].zfill(n))
print(bin(mask - b)[2:].zfill(n))